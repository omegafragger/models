# Copyright 2017 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# =============================================================================

"""Build extension rules for XLA AOT compilation."""

load(
    "//dragnn/runtime:multiarch.bzl",
    "multiarch_name",
    "MULTIARCH_CONFIGS",
)
load("@org_tensorflow//tensorflow/compiler/aot:tfcompile.bzl", "tf_library")

MULTIARCH_TFCOMPILE_FLAGS = {
    "generic": [],
    "avx": ["--target_features=+avx,+sse4.2"],
    "avx2fma": ["--target_features=+avx,+avx2,+sse4.2,+fma"],
}

def _dragnn_xla_safe_name(name):
  """Generates a version of |name| is safe for use in C++."""
  return name.replace('-','_').replace('.','_')

def _dragnn_xla_aot_library_name(arch, model, component):
  """Returns the AOT library name for the given model/component."""
  return multiarch_name(model + '_' + component, arch)

def _dragnn_xla_aot_component_library_name(arch, model, component):
  """Returns the AOT component library name for the given model/component."""
  return _dragnn_xla_aot_library_name(arch, model, component) + '_component'

def _dragnn_xla_config_proto(
    name, graph,
    config_tool = '//dragnn/runtime/xla:xla_extract_config'):
  """Extracts XLA Config from a frozen GraphDef for a DRAGNN component.

  Generates a build target called |name| which is a text file that contains
  a tensorflow.tf2xla.Config used in a tf_library build rule. The output
  file is called "<name>.pbtxt".

  Args:
    name: The name of the build rule.
    graph: The frozen tensorflow.GraphDef binary proto built for a particular
      DRAGNN component by the runtime.
    config_tool: The binary used to extract the Config proto. A non-default
      can be passed when necessary.
  """
  config_path = name + '.pbtxt'
  native.genrule(
      name=name,
      srcs=[graph],
      outs=[config_path],
      tools=[config_tool],
      cmd=('$(location ' + config_tool + ')' +
           ' $(location ' + graph + ')' +
           ' $(location ' + config_path + ')')
  )

def _dragnn_xla_aot_component_cc_code(arch, model, component, target):
  """Generates C++ code for a component which wraps a particular AOT library.

  Returns a string containing the generated C++ code that defines and registers
  the DRAGNN component the implements a particular |model| and |component|,
  targeted to a the given |arch|. The class name and registry name do not
  include |arch|, which means only one can be linked in.

  Args:
    arch: The name of the target architecture.
    model: The name of the DRAGNN model.
    component: The name of the DRAGNN component that uses XLA AOT.
    target: The directory that contains XLA AOT target.

  Returns:
    The string containing the generated C++ code.
  """
  cc_template = """// GENERATED CODE.
#include "$TARGET/$MODEL_$COMPONENT_multiarch_$ARCH.h"  // Generated by XLA.
#include "dragnn/runtime/xla/sequence_xla_dynamic_component_mixin.h"
#include "dragnn/runtime/xla/xla_aot_dynamic_component.h"

namespace syntaxnet {
namespace dragnn {
namespace runtime {
namespace {

class XlaAotDynamicComponent_$MODEL_$COMPONENT
    : public XlaAotDynamicComponent<$MODEL::$COMPONENT> {
 public:
  XlaAotDynamicComponent_$MODEL_$COMPONENT()
      : XlaAotDynamicComponent<$MODEL::$COMPONENT>("$MODEL", "$COMPONENT") {}
};

DRAGNN_RUNTIME_REGISTER_COMPONENT(XlaAotDynamicComponent_$MODEL_$COMPONENT);

using SequenceXlaAotDynamicComponent_$MODEL_$COMPONENT =
    SequenceXlaDynamicComponentMixin<XlaAotDynamicComponent_$MODEL_$COMPONENT>;

DRAGNN_RUNTIME_REGISTER_COMPONENT(
    SequenceXlaAotDynamicComponent_$MODEL_$COMPONENT);

}  // namespace
}  // namespace runtime
}  // namespace dragnn
}  // namespace syntaxnet
"""
  return cc_template.replace('$ARCH', arch).replace('$TARGET', target).replace(
      '$MODEL', model).replace('$COMPONENT', component)

def _dragnn_xla_aot_component_library(arch, model, component,
                                      tags=None, testonly=0):
  """Generates and compiles the component library that wraps the AOT binary.

  Args:
    arch: The name of the target architecture.
    model: The name of the DRAGNN model.
    component: The name of the DRAGNN component that uses XLA AOT.
    tags: tags to apply to subsidiary build rules.
    testonly: If 1, only testonly targets can depend on this target.
  """
  xla_aot_library = _dragnn_xla_aot_library_name(arch, model, component)
  xla_aot_component_library = _dragnn_xla_aot_component_library_name(
      arch, model, component)
  xla_aot_component_src = xla_aot_component_library + '.cc'

  native.genrule(
      name=xla_aot_component_library + '_cc',
      outs=[xla_aot_component_src],
      cmd = "cat << 'EOF' >$@\n{}\nEOF\n".format(
          _dragnn_xla_aot_component_cc_code(
              arch, model, component, native.package_name())
      ),
      tags=tags,
      testonly=testonly,
  )
  native.cc_library(
      name=xla_aot_component_library,
      srcs=[xla_aot_component_src],
      deps = [
          multiarch_name(
              '//dragnn/runtime/xla:sequence_xla_dynamic_component_mixin',
              arch),
          multiarch_name(
              '//dragnn/runtime/xla:xla_aot_dynamic_component',
              arch),
          ':' + xla_aot_library,
      ],
      testonly=testonly,
      alwayslink=1
  )

def _dragnn_xla_aot_library(name, arch, model, component, graph,
                            tags=None, testonly=0):
  """Runs tfcompile to AOT-compile a frozen GraphDef for a DRAGNN component.

  Generates a build target called |name| which is a cc_library containing
  the generated header and AOT-compiled function that implements a specific
  DRAGNN component. For details on compilation see:
    @org_tensorflow//tensorflow/compiler/aot/tfcompile.bzl

  The generated library contains the following C++ class:
    syntaxnet::dragnn::runtime::<model>::<component>
  and the output file is called <name>.h

  There is also build target called <name>-config which contains the
  Config proto used by XLA.

  Args:
    name: The name of the build rule.
    arch: The name of the target architecture.
    model: The name of the DRAGNN model that contains this component.
    component: The name of the DRAGNN component in the ComponentSpec.
    graph: The frozen tensorflow.GraphDef binary proto built for a particular
       DRAGNN component by the runtime.
    tags: tags to apply to subsidiary build rules.
    testonly: If 1, only testonly targets can depend on this target.

  """

  # Gets the Config proto needed by tfcompile.
  xla_config_name = name + '-config'
  _dragnn_xla_config_proto(
      name=xla_config_name,
      graph=graph
  )

  # Runs tfcompile to AOT-compile the GraphDef.
  tf_library(
      name=_dragnn_xla_aot_library_name(arch, model, component),
      graph=graph,
      config=xla_config_name,
      cpp_class='syntaxnet::dragnn::runtime::' + model + '::' + component,
      tfcompile_flags = ' '.join([
          '--gen_name_to_index=true',
          '--gen_program_shape=true',
          '--xla_cpu_multi_thread_eigen=false',
      ] + MULTIARCH_TFCOMPILE_FLAGS[arch]),
      tags=tags,
      testonly=testonly,
  )

  # Generates the component library that wraps the AOT library.
  _dragnn_xla_aot_component_library(arch, model, component, tags, testonly)

def dragnn_xla_aot_components(name, component_data, tags=None, testonly=0):
  """Generates targets for all XLA AOT components in |component_data|.

  Every element in the list |component_data| is also a list, which contains:
    - name of the DRAGNN model;
    - name of the component;
    - relative path to the frozen GraphDef proto.

  If multiple models exist in the same binary, the model name must uniquely
  identify this specific model instance, e.g. 'parser_v20171101'.

  Args:
    name: The name of the build rule.
    component_data: A list of per-component-data that is necessary to build
      the AOT library and the component that wraps it.
    tags: tags to apply to subsidiary build rules; the arch-specific tags
      are included.
    testonly: If 1, only testonly targets can depend on this target.
  """
  safe_component_data = [
      [
          _dragnn_xla_safe_name(model),
          _dragnn_xla_safe_name(component),
          graph
      ]
      for [model, component, graph] in component_data]

  # Generates the AOT library and component targets.
  for arch in MULTIARCH_TFCOMPILE_FLAGS:
    for [model, component, graph_path] in safe_component_data:
      _dragnn_xla_aot_library(
          name=_dragnn_xla_aot_library_name(arch, model, component),
          arch=arch,
          model=model,
          component=component,
          graph=graph_path,
          tags=(tags if tags else []) + MULTIARCH_CONFIGS[arch]['tags'],
          testonly=testonly,
      )

  # Composes a library with all of the AOT library and component targets.
  for arch in MULTIARCH_TFCOMPILE_FLAGS:
    native.cc_library(
        name=multiarch_name(name, arch),
        deps = [
            ':' + _dragnn_xla_aot_component_library_name(
                arch, model, component)
            for [model, component, _] in safe_component_data
        ],
        tags=(tags if tags else []) + MULTIARCH_CONFIGS[arch]['tags'],
        testonly=testonly,
    )

def dragnn_xla_aot_bazel_test(name, srcs):
  """Verifies that generated bzl matches what is checked in.

  Passes when the generated file <name>_gen.bzl and the currently
  existing one in <name>.bzl match.

  Args:
    name: The name of the bzl to test (without .bzl)
    srcs: A set of MasterSpec files
  """
  generated_bzl = name + '-gen.bzl'
  native.genrule(
      name=name + '_gen',
      outs = [generated_bzl],
      cmd = ('$(location '+
             '//dragnn/runtime/xla:xla_extract_names_from_specs) ' +
             native.package_name() + ' $(SRCS) $(OUTS)'),
      tools=['//dragnn/runtime/xla:xla_extract_names_from_specs'],
      srcs=srcs)

  # Makes a copy of file_diff_test in this package.
  native.genrule(
      name = 'repackage_file_diff_test',
      srcs = ['//dragnn/python:file_diff_test.py'],
      outs = ['%s/file_diff_test.py' % native.package_name()],
      cmd = 'cp $< $@',
  )

  # Compare the generated file.
  expected_bzl = name + '.bzl'
  native.py_test(
      name = name,
      srcs = ['%s/file_diff_test.py' % native.package_name()],
      main = '%s/file_diff_test.py' % native.package_name(),
      deps = ['//dragnn/python:file_diff_test'],
      args = [
          '--actual_file=$(location ' + generated_bzl + ')',
          '--expected_file=$(location ' + expected_bzl + ')',
      ],
      data = [expected_bzl, generated_bzl],
  )
